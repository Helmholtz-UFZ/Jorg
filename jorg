#!/usr/bin/env bash

# Commands returning a non-zero exit code will cause an immediate exit
set -e

jorg_version=1.0.0

function display_version() {
    echo "$jorg_version"
    exit 1
}

function display_help() {
    echo "--------------------------------------------------------------------------"
    echo "Jorg - Circularization and improvement of metagenomic bins - version $jorg_version"
    echo " "
    echo "Authors: Lauren Lui (lmlui@lbl.gov), Torben Nielsen, Adam Arkin"
    echo "--------------------------------------------------------------------------"
    echo " "
    echo "Usage: jorg -b bin.186.fa -r SRX3307784_clean.fastq.gz -k 33 -c 50 -i 5"
    echo
    echo "   -b, --bin_fasta_file       Genome bin in fasta format."
    echo "   -r, --reads_file           Metagenome reads file in fastq or fastq.gz format."
    echo "   -k, --kmer_length          Kmer value for baiting (default: 33)."
    echo "   -c, --min_coverage         Minimum coverage value (default: 50)."
    echo "   -i, --iterations           Number of iterations (default: 5)."
    echo "   -v, --version              Print version number and exit."
    echo "   -h, --help                 Show this message."
    echo " "
    echo "Note: the fastq file prefix needs to NOT be named the same as fasta file - "
    echo "(e.g., do not input bin_186.fasta and bin_186.fastq)"
    echo " "
    echo "Please cite: Lui LM, Nielsen TN, Arkin AP. 2020, biorxiv (https://www.biorxiv.org/content/10.1101/2020.03.05.979740v2.full)."
    exit 1
}

[ $# -eq 0 ] && { display_help ; exit 1; }

bin_fasta_file="NULL"
reads_file="NULL"
debug=false
kmer_length=33
min_coverage=50 # originally 200, may need to fix. 50 required to prevent filtering all contigs after iteration #1
iterations=5

while [ "$1" != "" ]; do
    case $1 in
        -k | --kmer_length )    shift
                                kmer_length=$1
                                ;;
        -c | --min_coverage )   shift
                                min_coverage=$1
                                ;;
        -i | --iterations )     shift
                                iterations=$1
                                ;;
        -b | --bin_fasta_file ) shift
                                bin_fasta_file=$1
                                ;;
        -r | --reads_file )     shift
                                reads_file=$1
                                ;;
        -v | --version )        shift
                                display_version
                                exit
                                ;;
        -h | --help )           display_help
                                exit
                                ;;
        * )                     display_help
                                exit 1
    esac
    shift
done

if [[ ! "$bin_fasta_file" = *[!\ ]* ]]; then
    echo "Input bin fasta file not defined (set using -b, --bin_fasta_file). Exiting."
    exit 1
fi

if [[ ! "$reads_file" = *[!\ ]* ]]; then
    echo "Input reads fastq file not defined (set using -r, --reads_file). Exiting."
    exit 1
fi

jorg_logfile="Jorg_${bin_fasta_file}_$(date +%c | sed 's/[: ]/-/g').log"

# Check for MIRA installation
command -v mira >/dev/null 2>&1 || { echo >&2 "Error: unable to locate MIRA. Please make sure MIRA is installed on your system. Exiting."; exit 1; }

# Check for MIRABAIT installation
command -v mirabait >/dev/null 2>&1 || { echo >&2 "Error: unable to locate MIRABAIT. Please make sure MIRABAIT is installed on your system. Exiting."; exit 1; }

# Check for Seqtk installation
command -v seqtk >/dev/null 2>&1 || { echo >&2 "Error: unable to locate Seqtk. Please make sure Seqtk is installed on your system. Exiting."; exit 1; }

# Check for other installations?

# Capture seqtk stout
#seqtk 2> /tmp/seqtk_version.tmp

# Start logging
echo " "
echo "Writing log to file:"$jorg_logfile
echo "Jorg run on " $(date) | tee -a "$jorg_logfile"
echo "" | tee -a "$jorg_logfile"
echo "User environment details:" | tee -a "$jorg_logfile"
echo "MIRA path:" $(which mira) | tee -a "$jorg_logfile"
echo "MIRA version:" $(mira --version | grep MIRA | sed 's/MIRA //' 2>&1) | tee -a "$jorg_logfile"
echo "MIRABAIT path:" $(which mirabait) | tee -a "$jorg_logfile"
echo "MIRABAIT version:" $(mirabait --version | grep MIRA | sed 's/MIRABAIT //' 2>&1) | tee -a "$jorg_logfile"
#echo "seqtk path:" $(which seqtk) | tee -a "$jorg_logfile"
#echo "seqtk version:" $(grep Version /tmp/seqtk_version.tmp | sed 's/Version: //' 2>&1) | tee -a "$jorg_logfile"
# echo "ruby path:" $(which ruby) | tee -a "$jorg_logfile"
# echo "ruby version:" $(ruby --version) | tee -a "$jorg_logfile"


# Check for existence of files
if [ ! -f "$bin_fasta_file" ]; then
    echo "bin_fasta_file file not found: $bin_fasta_file" | tee -a "$jorg_logfile"
    echo "Exiting." | tee -a "$jorg_logfile"
    exit 1
fi

if [ ! -f "$reads_file" ]; then
    echo "contig file not found: $reads_file" | tee -a "$jorg_logfile"
    echo "Exiting." | tee -a "$jorg_logfile"
    exit 1
fi

echo "***Start running Jorg***" | tee -a "$jorg_logfile"

####### Prep files #######

# Get the bin ID by removing the file extension
# filepath="bin.186.fa"
filepath=${bin_fasta_file}
filename=$(basename "$filepath")
binID=$(echo "${filename%.*}" )

# Copy original file to avoid rewriting over it
outfile="$binID".out.fasta
# cp bin.186.fa "$outfile"
cp "$bin_fasta_file" "$outfile"

# Make manifest file for MIRA
echo "Start: make manifest file for MIRA" | tee -a "$jorg_logfile"
cat manifest_template.conf | sed "s/XXX/$binID/g" > manifest.conf
echo "End: make manifest file for MIRA" | tee -a "$jorg_logfile"

# Create file for contig stats of iterations
printf "contig_name\tlength\tGC_percent\tcumulative_length\n" > iterations.txt

####### Iterate recruiting reads and MIRA assembly #######

echo "Start: generating new directory named 'Iterations'" | tee -a "$jorg_logfile"
mkdir -p Iterations
echo "End: generating new directory named 'Iterations'" | tee -a "$jorg_logfile"

for (( i = 1; i <= "$iterations"; i++ ))
do
    echo "Start: Jorg iteration # "${i} | tee -a "$jorg_logfile"
    echo "Iteration "${i} >> iterations.txt

    # Recruit reads with mirabait
    echo "Start: recruiting reads with mirabait" | tee -a "$jorg_logfile"
    # mirabait -k 33 -b "$outfile" -P SRX3307784_clean.fastq -o "$binID".fastq &> mirabait.log
    mirabait -k "$kmer_length" -b "$outfile" -P "$reads_file" -o "$binID".fastq &> mirabait_iteration_${i}.log
    echo "End: recruiting reads with mirabait" | tee -a "$jorg_logfile"

    #Check if the reads file is empty.  Seqtk will hang if the input file is empty.
    echo "Start: check if fastq file empty." | tee -a "$jorg_logfile"
    if [ ! -s "$binID".fastq ]; then
        echo "Error: fastq file empty." | tee -a "$jorg_logfile"
        exit 1
    fi
    echo "End: check if fastq file empty." | tee -a "$jorg_logfile"

    # Deinterleave reads
    echo "Start: deinterleaving reads" | tee -a "$jorg_logfile"
    seqtk seq -1 -C ${binID}.fastq | seqtk rename - ${binID}_ | sed "s/\(^@${binID}_[0-9][0-9]*$\)/\1\/1/" > ${binID}_1.fastq
    echo "Forward reads extracted" | tee -a "$jorg_logfile"
    seqtk seq -2 -C ${binID}.fastq | seqtk rename - ${binID}_ | sed "s/\(^@${binID}_[0-9][0-9]*$\)/\1\/2/" > ${binID}_2.fastq
    echo "Reverse reads extracted" | tee -a "$jorg_logfile"
    echo "End: deinterleaving reads" | tee -a "$jorg_logfile"

    # Run MIRA assembly
    echo "Start: run MIRA assembly" | tee -a "$jorg_logfile"
    mira manifest.conf &> mira_iteration_${i}.log
    echo "End: run MIRA assembly" | tee -a "$jorg_logfile"

    # Get MIRA assembly file
    echo "Start: get MIRA assembly file" | tee -a "$jorg_logfile"
    cp "$binID"_assembly/"$binID"_d_results/"$binID"_out.unpadded.fasta "$binID"_MIRA.fasta
    echo "End: get MIRA assembly file" | tee -a "$jorg_logfile"

    # Get contigs that are greater than 1000bp and have coverage greater than the indicated minimum
    echo "Start: get contigs >1000bp and with sufficient coverage" | tee -a "$jorg_logfile"
    awk -v coverage_min="$min_coverage" '{if($2 >= 1000 && $6 >= coverage_min || NR == 1) print}' "$binID"_assembly/"$binID"_d_info/"$binID"_info_contigstats.txt > list.txt
    echo "End: get contigs >1000bp and with sufficient coverage" | tee -a "$jorg_logfile"

    # Check to see if any contigs passed criteria for minimum length and minimum coverage
    echo "Start: check for contigs passing minimum length and coverage criteria." | tee -a "$jorg_logfile"
    if [[ $(wc -l <list.txt) -ge 2 ]]; then
        echo "At least one contig passed criteria for minimum length and minimum coverage - will continue attempting to close genome." | tee -a "$jorg_logfile"
    else # no contigs passed criteria
        echo "Zero contigs passed criteria for minimum length and minimum coverage. Exiting." | tee -a "$jorg_logfile"
        exit 1
    fi
    echo "End: check for contigs passing minimum length and coverage criteria." | tee -a "$jorg_logfile"

    #Check if the outfile is empty.  Seqtk will hang if the input file is empty.
    echo "Start: check if input fasta file empty." | tee -a "$jorg_logfile"
    if [ ! -s "$outfile" ]; then
        echo "Error: fasta outfile empty."
        exit 1
    fi
    echo "End: check if input fasta file empty." | tee -a "$jorg_logfile"

    # Output assembly based on stats collected in list.txt
    echo "Start: output assembly based on stats collected in list.txt" | tee -a "$jorg_logfile"
    seqtk subseq "$binID"_MIRA.fasta list.txt > "$outfile"
    echo "End: output assembly based on stats collected in list.txt" | tee -a "$jorg_logfile"

    # Output contig stats on assembly
    # contig_name  length  %GC  cumulative_length
    echo "Start: output contig stats on assembly" | tee -a "$jorg_logfile"
    seqtk comp $binID.out.fasta | sort -k 2,2nr | awk '{printf "%-40s %8d %7.2f %8d\n", $1, $2, 100.0 * ($4 + $5)/($3 + $4 + $5 + $6), sum += $2}' >> iterations.txt
    echo "End: output contig stats on assembly" | tee -a "$jorg_logfile"

    echo "Start: copy working fasta file to Iterations folder" | tee -a "$jorg_logfile"
    cp $binID.out.fasta Iterations/$binID_${i}.fasta
    echo "End: copy working fasta file to Iterations folder" | tee -a "$jorg_logfile"

    echo "End: Jorg iteration # "${i} | tee -a "$jorg_logfile"

done

echo "***End running Jorg***" | tee -a "$jorg_logfile"
